import requests
import tmdbsimple as tmdb
import time
import urllib


"""
Uncomment and adjust these three variables as needed
A Jellyfin API key can be generated by going to the admin page,
Advanced -> Security
You must have an account with themoviedb to get an API key
https://developers.themoviedb.org/3/getting-started/introduction
"""
#serverURL = "http://localhost:8096/emby"
#jellyfinApiKey = "foo"
#tmdb.API_KEY = "bar"

headers = {'X-Emby-Token': jellyfinApiKey}

collections = {}
errors = []

# Get All Movies in library
library = requests.get(
    serverURL + "/Items?Recursive=true&IncludeItemTypes=Movie",
    headers=headers
)

# Loop through movies, looking them up at themoviedb.
for movie in library.json()['Items']:
    collectionID = ""
    jellyfinID = movie.get('Id')
    tmdbID = movie.get('ProviderIds').get('Tmdb')
    # sleep to avoid rate limit
    time.sleep(.5)
    try:
        movieInfo = tmdb.Movies(tmdbID).info()
        print("\nChecking " + movie.get("Name"))

        """
        If a movie is in a collection, it gets added to a local dictionary
        to be used later
        """
        if movieInfo.get('belongs_to_collection'):
            collectionID = movieInfo['belongs_to_collection'].get('id')
            rawCollectionName = movieInfo['belongs_to_collection'].get('name')
            print(movie.get("Name") + " belongs in the " + rawCollectionName)
            # URL encode the collection name for the jellyfin api
            collectionName = urllib.parse.quote(rawCollectionName)

            """
            Checks if a collection already exists in the dictionary.  If so,
            it adds it to the existing.  If not, it creates a new entry with
            the human readable name, the URL encoded name, and the jellyfin
            object IDs of each movie that belongs there
            """
            if collections.get(collectionID):
                collections[collectionID]["ids"].append(jellyfinID)
            else:
                collections[collectionID] = {

                    "Name": collectionName,
                    "rawName": rawCollectionName,
                    "ids": [ jellyfinID ]
                }
    except:
        # If any errors occur, add them to the errors list
        errors.append(str(movie.get("Name")))
        print("Error on " + movie.get("Name"))
        pass

# Write the errors list to a log file for manual review
with open("collection-errors.txt", "w") as errorFile:
    for error in errors:
        errorFile.write(error + '\n')

# Loop through the newly created dictionary, creating each collection
for collection, data in collections.items():
    if len(data['ids']) > 1:
        # Create a collection
        print("\nCreating " + data['rawName'])
        requests.post(
            serverURL + \
            "/Collections?Name=" + data['Name'],
            headers=headers
        )

print("""\n\n=================================
Data lookup complete.
Starting to create collections...
=================================\n\n""")

# Loops through everything added to the collections dictionary
for collection, data in collections.items():
    # Only create a collection if it has more than 1 entry
    if len(data['ids']) > 1:

        libraryCollections = requests.get(
            serverURL + "/Items?Recursive=true&IncludeItemTypes=BoxSet",
            headers=headers
        ).json()['Items']

        try:
            # pulls out the ID of the jellyfin collection
            libraryCollectionID = [
                x['Id'] for x in libraryCollections if x['Name'] == data['rawName']
            ][0]

            # Adds movies to each collection
            requests.post(
                serverURL + \
                "/Collections/" + libraryCollectionID + "/Items" + \
                "?Ids=" + ",".join(data['ids']),
                headers=headers
            )
            print("Added movies to " + data['rawName'])
        except:
            print("There was an error sorting: " + data['rawName'])
            pass

# Finds ID of Collections library in jellyfin
folders = requests.get(serverURL + "/Library/MediaFolders", headers=headers)
folderID = [
    x['Id'] for x in folders.json()['Items'] if x['Name'] == "Collections"
][0]

# Triggers a refresh of the metadata in the collections library
refresh = requests.post(
    serverURL + "/Items/" + folderID + "/Refresh?" + \
    "Recursive=true&" + \
    "MetadataRefreshMode=FullRefresh&" + \
    "ImageRefreshMode=FullRefresh",
    headers=headers
)

print("""\n\n=================================
Collection generation complete
=================================\n\n""")
